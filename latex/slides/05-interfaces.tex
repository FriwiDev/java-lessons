\input{../templates/course_definitions}
\input{../templates/course_information}

\title{Java}
\subtitle{Interfaces}
\date{\today}

\begin{document}

\begin{frame}
\titlepage
\end{frame}

\begin{frame}{Overview}
\tableofcontents
\end{frame}

\section{Additional Control Structure}
\subsection{Switch}
\begin{frame}[fragile]{Differentiate}
    \begin{lstlisting}[basicstyle=\ttfamily\scriptsize]
    public static void main (String[] args) {
    
        int address = 2;
            
        if (address == 1) {
            System.out.println("Dear Sir,");        
        } else if (address == 2) {
            System.out.println("Dear Madam,");            
        } else if (address == 4) {
            System.out.println("Dear Friend,");            
        } else {
            System.out.println("Dear Sir/Madam,");    
        }
    }\end{lstlisting}
\end{frame}
\begin{frame}[fragile]{Differentiate with Switch}
    \begin{lstlisting}[basicstyle=\ttfamily\scriptsize]
    public static void main (String[] args) {
    
        int address = 2;
        
        switch(address) {
            case 1:
                System.out.println("Dear Sir,");
                break;
            case 2:
                System.out.println("Dear Madam,");
                break;
            case 4:
                System.out.println("Dear Friend,");
                break; 
            default:
                System.out.println("Dear Sir/Madam,");
                break;
        }
    }\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Break}
    After the last command of the case block    you can tell the program to leave using \textbf{break}.\\
    Without \textbf{break} the program will continue regardless of
    whether a new case started, like in the example below.
    \begin{lstlisting}[basicstyle=\ttfamily\scriptsize]
    public static void main (String[] args) {
    
        switch( 1 ) {
            case 1:
                System.out.println("enter case 1");
            case 2:
                System.out.println("enter case 2");
                break;
            default:
                System.out.println("enter default case");
                break;
        }
    }\end{lstlisting}
\end{frame}

\subsection{Break \& Continue}
\begin{frame}[fragile]{Break}
    The keyword \textbf{break} also stops the execution of loops.
    \begin{lstlisting}[basicstyle=\ttfamily\scriptsize]
    public static void main (String[] args) {
    
        for (int i = 1; 1 < 10; i++) {
            System.out.println("i = " + i);
            if (i == 3) {
                break;
            }
        }
    }\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Continue}
    The keyword \textbf{continue} jumps to the next loop step.
    \begin{lstlisting}[basicstyle=\ttfamily\scriptsize]
    public static void main (String[] args) {
    
        for (int i = 1; 1 < 10; i++) {
            if (i == 3) {
                continue;
            }
            System.out.println("i = " + i);
        }
    }\end{lstlisting}
\end{frame}

\subsection{return}
\begin{frame}[fragile]{return}
    Return statement gives back data
    \begin{lstlisting}[basicstyle=\ttfamily\scriptsize]
    class Numbers {
        private int a = 4;
        private int b = 5;
        
        public Number() {}
        
        public int addNumbers() {
            return a + b;
        }
    }
    
    ...
    
    Numbers numbers = new Numbers();
    int return = numbers.addNumbers();\end{lstlisting}
    
    Return works with every primitiv and complex data type.
    
\end{frame}

\begin{frame}[fragile]{return}
    \begin{lstlisting}[basicstyle=\ttfamily\scriptsize]
    public String getName() {
        return "Klaus";
    }
    
    private Calculator calc;
    public Calculator getCalcualtor() {
        return calc;
    }\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{return}
    Functions of type void do not have a return value.
    They are used for e.g. Setters
    \begin{lstlisting}[basicstyle=\ttfamily\scriptsize]
    public void setNumber(int number) {
        this.number = number;
    }\end{lstlisting}
\end{frame}

\section{Static}
\subsection{Overview}
%TODO improve this overview - add an example - think about the headline
\begin{frame}{Static Keyword}
    
    Static attributes or methods do not belong to the objects of a class.
    They belong to the class itself.

\end{frame}

\subsection{Examples}
\begin{frame}[fragile]{Class Variables}
    \begin{lstlisting}
    public class Example {
    
        public static int classCounter;
        public int myCounter;

        public addCount(int count) {
            // all objects share this one classCounter
            Example.classCounter += count;
            
            // every object has their own myCounter
            this.myCounter += count;
        }
    }\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Class Variables - Test}
    \begin{lstlisting}[basicstyle=\ttfamily\scriptsize]
    public class ExampleTest {
    
        public static void main (String[] args) {
            Example e1 = new Example();
            Example e2 = new Example();
            
            e1.addCount(4);
            e2.addCount(5);
            
            System.out.println(e1.myCounter);
            System.out.println(e2.myCounter);
            System.out.println(Example.classCounter);
        }
    }\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Class Methods}
    Static methods can be called without an object.
    They can modify class variables but not attributes (object variables).
    \begin{lstlisting}
    public class Example {
    
        public static count;

        public static void setCount(int count) {
            Example.count = count;
        }
    }\end{lstlisting}
    \begin{lstlisting}
    public static void main (String[] args) {
            
        Example.setCount(4);
    }\end{lstlisting}
\end{frame}

%\begin{frame}{When to use Static?}
%    The main method is static.
%\end{frame}

%\section{Abstract}
%\subsection{}
%\begin{frame}{}
%\end{frame}

%\begin{frame}{Singleton}
%\end{frame}

\section{Interfaces}
\subsection{Overview}
\begin{frame}{}
    An \textbf{interface} is a well defined set of methods a class has to \textbf{implement}.
    \vfill
    \textbf{Example:}
    Letters, postcards and packages can all be tracked. They might be derived from different classes.
    But ultimately each of them behaves similar as ``something that can be tracked``.
    
    %vfill
    %conclusion: Seperation from definition and implementation. 
    %The definition is ?denoted by? the interface.
\end{frame}
\subsection{Example}
\begin{frame}[fragile]{Interface Trackable}
    An interface contains method signatures. A signature is the definition of a method without the implementation.
    \begin{lstlisting}
    public interface Trackable {
    
        public int getStatus();
        
        public Position getPosition();
    }\end{lstlisting}
    Note: The name of an interface often ends with the suffix \emph{-able}.
\end{frame}
\begin{frame}[fragile]{Letter implements Trackable}
    \begin{lstlisting}
    public class Letter implements Trackable {
    
        public Position position;
        private int identifier;
    
        public int getStatus() {
            return this.identifier;
        }
        
        public Position getPosition() {
            return this.position;
        }
    }\end{lstlisting}
    The classes \emph{Postcard} and \emph{Package} also implement the interface \emph{Trackable}.
\end{frame}

\begin{frame}[fragile]{Access through an Interface}
    \begin{lstlisting}
    public static void main(String[] args) {
    
        Trackable myLetter = new Letter();
        Trackable myPackage = new Package();
        Trackable myPostcard = new Postcard();
        
        Position pos = myLetter.getPosition();
        int status = myPostcard.getStatus();
    }\end{lstlisting}
\end{frame}

\subsection{Multiple Interfaces}
\begin{frame}[fragile]{Two Interfaces}
    A class can implement multiple interfaces.
    \vfill
    \begin{lstlisting}[basicstyle=\ttfamily\scriptsize]
    public interface Buyable {
    
        public float getPrice();
    }\end{lstlisting}
    \begin{lstlisting}[basicstyle=\ttfamily\scriptsize]
    public interface Trackable {
    
        public int getStatus);
        
        public Position getPosition();
    }\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Postcard implements Buyable and Trackable}
    \begin{lstlisting}[basicstyle=\ttfamily\scriptsize]
    public class Postcard implements Buyable, Trackable {
    
    
        public Position position;
        private int identifier;
        private float price;
        
        public float getPrice() {
            return this.price;
        }
    
        public int getStatus() {
            return this.identifier;
        }
        
        public Position getPosition() {
            return this.position;
        }
    }\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Access multiple Interfaces}
    \begin{lstlisting}
    public static void main(String[] args) {
    
        Postcard postcard = new Postcard();
        
        Trackable trackable = postcard;
        Buyable buyable = postcard;

        ... = postcard.getStatus();
        ... = postcard.getPrice();
        
        ... = trackable.getStatus();
        ... = trackable.getPrice();
        
        ... = buyable.getStatus();
        ... = buyable.getPrice();
    }\end{lstlisting}
    Careful, two lines are wrong!
\end{frame}
%deault methods and static methods
\end{document}